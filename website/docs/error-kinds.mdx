---
title: Error Kinds

description: Pyrefly error categories and suppression codes
---

# Error Kinds

An _error kind_ categorizes an error by the part of the typing specification
that an error is related to. Every error has exactly one kind.

The main use of error kinds is as short names ("slugs") that can be used in
error suppression comments.

## annotation-mismatch

This error indicates a mismatch between multiple annotations for a single
variable. This is relatively uncommon, but it can happen in if-statements:

```python
if some_cond:
    x: int = 1
else:
    x: str = "two" # Inconsistent type annotations for x: str, int [annotation-mismatch]
```

It can be helpful to annotate the variable before branch, especially if there is
a useful default value for it. For example:

```python
x: str = "default"
if some_cond:
  x = "actual value"
```

## assert-type

An `assert-type` error is raised when a `typing.assert_type()` call fails.

This error kind should never be suppressed, since that rather defeats the point
of of `typing.assert_type()`.

## async-error

`async-error` is reported when attempting to `await` on something that is not
awaitable. This may indicate that a function should have been marked `async` but
wasn't.

```python
def some_func() -> None:
  ...

await some_func() # Expression is not awaitable [async-error]
```

This will also arise if the context manager used in an `async with` statement
has `__aenter__` and `__aexit__` methods that are not marked `async`.

The fix is to use an `async` function in the `await`. This may mean making the
function `async` or finding an existing `async` function to use instead.

## bad-argument-count

This error arises when a function is called with the wrong number of arguments.

```python
def takes_three(one: int, two: int, three: int) -> complex:
  ...

take_three(3, 2)  # Expected 1 more positional argument [bad-argument-count]
```

Note that `missing-argument` will be raised if pyrefly can identify that
specific arguments are missing. As such, this error is more likely to appear
when too many args are supplied, rather than too few.

This example shows both kinds of errors:

```python
from typing import Callable
def apply(f: Callable[[int, int], int]) -> int:
    return f(1)  # Expected 1 more positional argument [bad-argument-count]
apply() # Missing argument `f` in function `apply` [missing-argument]
```

## bad-argument-type

This error indicates that the function was called with an argument of the wrong
type.

```python
def example(x: int) -> None:
  ...
example("one")  # Argument `Literal['two']` is not assignable to parameter `x` with type `int` in function `example` [bad-argument-type]
```

This can also happen with `*args` and `**kwargs`:

```python
def bad_args(*args: int) -> None:
  ...

bad_args(1, "two")  # Argument `Literal['two']` is not assignable to parameter with type `int` in function `bad_args` [bad-argument-type]
```

```python
def bad_kwargs(**kwargs: int) -> None:
  ...

bad_args(x=1, y="two")  # Keyword argument `y` with type `Literal['two']` is not assignable to kwargs type `int` in function `bad_kwargs` [bad-argument-type]
```

## bad-assignment

The most common cause of this error is attempting to assign a value that conflicts with the variable's type annotation.

```python
x: str = 1 # `Literal[1]` is not assignable to `str` [bad-assignment]
```

However, it can occur in several other situations.

Here, `x` is marked as `Final`, so assigning a new value to it is an error.

```python
from typing import Final
x: Final = 1
x = 2 # `x` is marked final [bad-assignment]
```

In another case, attempting to annotate an assignment to an instance attribute raises this error.

```python
class A:
    x: int
a = A()
a.x: int = 2  # Type cannot be declared in assignment to non-self attribute `a.x` [bad-assignment]
```

## bad-class-definition

This error indicates that there is something wrong with the class definition.
It tends to be a bit rarer, since most issues would be tagged with other error kinds, such as
`annotation-mismatch` or one of the function errors.
inheritance has its own complexities, so it has its own error kind called `invalid-inheritance`.

One place you may see it is dynamic class generation:

```python
from enum import Enum
Ex = Enum("Ex", [("Red", 1), ("Blue", 2), ("Red", 3)])  # Duplicate field `Red` [bad-class-definition]
```

However, it is best practice to use the class syntax if possible, which doesn't treat duplicate names as an error.

## bad-function-definition

Like `bad-class-definition`, this error kind is uncommon because other error kinds are used for more specific issues.
For example, argument order is enforced by the parser, so `def f(x: int = 1, y: str)` is a `parse-error`.

## bad-keyword-argument

bad-keyword-argument pops up when a keyword argument is given multiple values:

```python
def f(x: int) -> None:
  pass
f(x=1, x=2)
```

However, this is often accompanied by a `parse-error` for the same issue.

## bad-override

When a subclass overrides a field or method of its base class, care must be taken that the override won't cause problems.

Some of these are obvious:

```python
class Base:
  def f(self, a: int) -> None:
    pass

class NoArg(Base):
  def f(self) -> None:
    pass

class WrongType(Base):
  def f(self, a: str) -> None:
    pass

def uses_f(b: Base) -> None:
  b.f(1)
```

These errors are rather obvious: `uses_f` will fail if given a `NoArg` or `WrongType` instance, because those methods don't expect an `int` argument!

The guiding idea here is the [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle), the idea that a subclass can stand in for a base class at any point without breaking the program.

This can be a little subtle at first blush. Consider:

```python
class Base:
  def f(self, a: int) -> None:
    pass

class Sub(Base):
  def f(self, a: float) -> None:
    pass
```

Is this OK? Yes! `int` is treated as a subclass of `float`, or to put it another way, a function that accepts `float` can accept every `int`.
That means everywhere that we call `Base.f` can safely call `Sub.f`.

The opposite case, where `Base.f` takes `float` and `Sub.f` takes `int`, is an error because `Sub.f` cannot accept every `float` value.

## bad-return

Arises when a function does not return a value that is compatible with the function's return type annotation.

```python
def bad_return() -> None:
  return 1
```

Real-world examples are often less obvious, of course, due to complex control flow and type relationships.

This error is also raised for generator functions:

```python
from typing import Generator
# Generator has 3 types: the yield, send, and return types.
def bad_gen() -> Generator[int, None, str]:
  yield 1
  return 2  # should be a str!
```

## bad-specialization

"Specialization" refers to instantiating a generic type with a concrete type.
For example, `list` is a generic type, and `list[int]` is that type specialized with `int`.

Each generic type has an expected number of type vars, and each type var can be bound or constrained.
Attempting to use specialize a generic type in a way that violates these specifications will result in a `bad-specialization` error:

```python
x: list[int, str]
```

## bad-unpacking

An error caused by unpacking, such as attempting to unpack a list, tuple, or iterable into the wrong number of variables.

```python
def two_elems() -> tuple[int, str]:
  return (1, "two")

a, b, c = two_elems()
```

Note that pyrefly can only report this error if it knows how many elements the thing being unpacked has.

```python
# A bare `tuple` could have any number of elements
def two_elems() -> tuple:
  return (1, "two")

a, b, c = two_elems()
```

## delete-error

This error occurs when attempting to `del` something that cannot be deleted.

Besides obvious things like built-in values (you can't `del True`!), some object attributes are protected from deletion.
For example, read-only and required `TypedDict` fields cannot be deleted.

## import-error

An error related to the import mechanism, such as when a module cannot be found.

The error message will include which paths were searched, such as the site package paths.
You may be missing a dependency, or you may need to inform Pyrefly where the module lives. See [Configuration](configuration.mdx) for further information.

## index-error

Attempting to access a container with an incorrect index.
This only occurs when Pyrefly can statically verify that the index is incorrect, such as with a fixed-length tuple.

```python
def add_three(x: tuple[int, int]) -> int:
  return x[0] + x[1] + x[2]
```

Pyrefly also knows the keys of `TypedDict`s, but those have their own error kind.

## internal-error

Ideally you'll never see this one. If you do, please consider [filing a bug](https://github.com/facebook/pyrefly/issues).

## invalid-annotation

There are several reasons why an annotation may be invalid. The most common case is misusing a typing special form, such as `typing.Final`, `typing.ClassVar`, `typing.ParamSpec`, and so on.

```python
from typing import *

# Final must have a value
a: Final
# ClassVar can only be used in a class body
b: ClassVar[int] = 1
```

The error messages will explain how the special form is being misused. Consult the [typing docs](https://docs.python.org/3/library/typing.html) and [typing spec](https://typing.python.org/en/latest/spec/) for more information.

## invalid-argument

This error is used to indicate an issue with an argument to special typing-related functions.

For example, `typing.NewType` is a handy special form for creating types that are distinct from a base type.


```python
from typing import *

# The first arg must match the name!
Mismatch = NewType("Wrong Name", int)

# NewTypes cannot be used in isinstance.
UserId = NewType("UserId", int)
if isinstance(1, UserId):
  ...
```

## invalid-inheritance

An error caused by incorrect inheritance in a class or type definition.
This can pop up in quite a few cases:
- Trying to subclass something that isn't a class.
- Subclassing a type that does not support it, such as a `NewType` or a `Final` class.
- Attempting to mix `Protocol`s with non-`Protocol` base classes.
- Trying to make a generic enum.
- Trying to give a `TypedDict` a metaclass.

And so on!

## invalid-literal

`typing.Literal` only allows a [limited set](https://typing.python.org/en/latest/spec/literal.html#legal-parameters-for-literal-at-type-check-time) of types as parameters.
Attempting to use `Literal` with anything else is an error.

```python
from typing import Literal

# These are legal
Literal[1.0]
Literal['a', 'b', 'c']
# This is not
class A:
  ...
Literal[A()]
```

## invalid-overload

The `@overload` decorator requires that the decorated function has at least two overloaded signatures and a base implementation.

```python
from typing import *

@overload
def no_base(x: int) -> None:
  pass

@overload
def no_base(x: str) -> int:
  pass
```

```python
@overload
def just_one(x: int) -> None:
  pass

def just_one(x: str) -> None:
  ...
```


## invalid-param-spec

This error is reported when `typing.ParamSpec` is defined incorrectly or misused. For example:

```python
from typing import *

P = ParamSpec("Name Must Match!")

P1 = ParamSpec("P1")
P2 = ParamSpec("P2")

def f(x, *args: P1.args, **kwargs: P2.kwargs) -> None:
  pass
```

Here, `P1.args` and `P2.kwargs` can't be used together; `*args` and `**kwargs` must come from the same `ParamSpec`.

## invalid-super-call

Attempting to call `super()` in a way that is not allowed. e.g. calling
`super(Y, x)` on an object `x` that does not match the class `Y`.

## invalid-syntax

Incorrect Python syntax, construct is not allowed in this position.

## invalid-type-var

An error caused by incorrect usage or definition of a TypeVar.

## invalid-type-var-tuple

An error caused by incorrect usage or definition of a TypeVarTuple.

## invalid-yield

Attempting to use `yield` in a way that is not allowed. e.g. `yield from` with
something that's not an iterable.

## match-error

An error caused by a bad match statement. e.g. Writing a Foo(x, y, z) pattern
when Foo only matches on (x, y).

## missing-argument

An error caused by calling a function without all the required arguments. Should
be used when we can name the specific arguments that are missing.

## missing-attribute

Attempting to access an attribute that does not exist.

## missing-module-attribute

Accessing an attribute that does not exist on a module.

## no-access

The attribute exists but does not support this access pattern.

## no-matching-overload

Attempting to call an overloaded function, but none of the signatures match.

## not-a-type

Attempting to use something that isn't a type where a type is expected. This is
a very general error and should be used sparingly.

## not-callable

Attempting to call a value that is not a callable.

## not-iterable

Attempting to use a non-iterable value as an iterable.

## parse-error

An error related to parsing or syntax.

## read-only

The attribute exists but cannot be modified.

## reveal-type

Raised by a call to `reveal_type()`.

## type-alias-error

An error related to type alias usage or definition.

## typed-dict-key-error

An error related to TypedDict keys. e.g. attempting to access a TypedDict with a
key that does not exist.

## unbound-name

Attempting to use a name that may be unbound or uninitialized.

## unexpected-keyword

An error caused by a keyword argument used in the wrong place.

## unknown-name

Attempting to use a name that is not defined.

## unsupported-operand

Attempting to apply an operator to arguments that do not support it.

## unsupported

Attempting to use a feature that is not yet supported.
